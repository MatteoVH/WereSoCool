(* ------------------- *)
(* simpleop: a combination of all possible point_ops (Tm, Ta, ...)  *)

simpleop : type.

simpleop_sil : (Silence: ratio) -> simpleop.
simpleop_id : simpleop.
simpleop :
  (FreqMult: ratio) (FreqAdd: ratio)
  (GainMult: ratio)
  (LenMult: ratio)
  (PanMult: ratio) (PanAdd: ratio) -> simpleop.

lrof : simpleop -> ratio -> prop.

lrof (simpleop_id) (ratio 1 1).
lrof (simpleop_sil R) R.
lrof (simpleop _ _ _ LR _ _) LR.

%extend simpleop.

from_pointop : point_op -> simpleop -> prop.

from_pointop (freqmult R) (simpleop R (ratio 0 1) (ratio 1 1) (ratio 1 1) (ratio 1 1) (ratio 0 1)).
from_pointop (freqadd R) (simpleop (ratio 1 1) R (ratio 1 1) (ratio 1 1) (ratio 1 1) (ratio 0 1)).
from_pointop (gainmult R) (simpleop (ratio 1 1) (ratio 0 1) R (ratio 1 1) (ratio 1 1) (ratio 0 1)).
from_pointop (lenmult R) (simpleop (ratio 1 1) (ratio 0 1) (ratio 1 1) R (ratio 1 1) (ratio 0 1)).
from_pointop (panmult R) (simpleop (ratio 1 1) (ratio 0 1) (ratio 1 1) (ratio 1 1) R (ratio 0 1)).
from_pointop (panadd R) (simpleop (ratio 1 1) (ratio 0 1) (ratio 1 1) (ratio 1 1) (ratio 1 1) R).
from_pointop (silence R) (simpleop_sil R).

combine : simpleop -> simpleop -> simpleop -> prop.

combine (simpleop_id) F F.
combine F simpleop_id F.
combine (simpleop_sil LR) F' (simpleop_sil LR'') :- lrof F' LR', ratio.mult LR LR' LR''.
combine (simpleop _ _ _ LR _ _) (simpleop_sil LR') (simpleop_sil LR'') :- ratio.mult LR LR' LR''.

compose_linear : (Mult1: ratio) (Add1: ratio) (Mult2: ratio) (Add2: ratio) (MultR: ratio) (AddR: ratio) -> prop.
(* (M1 * x + A1) * M2 + A2 = M1 * M2 * x + (A1 * M2 + A2) *)
compose_linear M1 A1 M2 A2 MR AR :-
  ratio.mult M1 M2 MR,
  ratio.mult A1 M2 A1M2, ratio.plus A1M2 A2 AR.

combine   (simpleop FM   FA   GM   LM   PM   PA)
          (simpleop FM'  FA'  GM'  LM'  PM'  PA')
          (simpleop FM'' FA'' GM'' LM'' PM'' PA'') :-
  compose_linear FM FA FM' FA' FM'' FA'',
  compose_linear PM PA PM' PA' PM'' PA'',
  ratio.mult GM GM' GM'', ratio.mult LM LM' LM''.

%end.

(* ------------------- *)
(* normal forms definition *)

normalprogram : type.
normalop : type.
voiceop : type.

normalprogram : option point -> normalop -> normalprogram.
overlays  : ratio -> list voiceop -> normalop.
sequences : list simpleop -> voiceop.

lrof : op -> ratio -> prop.

lrof id (ratio 1 1).
lrof (map F) Ratio :- simpleop.from_pointop F F', lrof F' Ratio.
lrof (seq O1 O2) Ratio :-
  lrof O1 Ratio1, lrof O2 Ratio2, ratio.plus Ratio1 Ratio2 Ratio.
lrof (overlay O1 O2) Ratio :-
  lrof O1 Ratio1, lrof O2 Ratio2, ratio.max Ratio1 Ratio2 Ratio.
lrof (compose O1 O2) Ratio :-
  lrof O1 Ratio1, lrof O2 Ratio2, ratio.mult Ratio1 Ratio2 Ratio.

lrof : normalop -> ratio -> prop.
lrof (overlays LR _) LR.

fold1 : (A -> A -> A -> prop) -> list A -> A -> prop.
fold1 P (HD :: TL) Result :-
  foldl P HD TL Result.

%extend normalop.

silence : (Voices: normalop) (SilenceRatio: ratio) -> normalop -> prop.
silence (overlays _ Voices) (ratio 0 D) (overlays (ratio 0 1) Voices') :-
  map (pfun unused => eq (sequences [])) Voices Voices'.

silence (overlays _ Voices) LR (overlays LR Voices') when not(eq LR (ratio 0 D)) :-
  map (pfun unused => eq (sequences [simpleop_sil LR])) Voices Voices'.

sequence : normalop -> normalop -> normalop -> prop.
sequence (overlays LR1 Overlays1) (overlays LR2 Overlays2) (overlays LR Overlays') :-
  ratio.plus LR1 LR2 LR,
  map (pfun (sequences Seq1) (sequences Seq2) (sequences Seq3) => append Seq1 Seq2 Seq3) Overlays1 Overlays2 Overlays'.

overlay : normalop -> normalop -> normalop -> prop.
overlay (overlays LR Overlays1) (overlays LR' Overlays2) (overlays LR'' Overlays') :-
  ratio.reduce LR LR'', ratio.reduce LR' LR''',
  if (not(eq LR'' LR''')) then (log_error _ `overlays do not have the same length! assertion failed`, failure) else success,
  append Overlays1 Overlays2 Overlays'.

map : ratio -> (simpleop -> simpleop -> prop) -> normalop -> normalop -> prop.
map : (simpleop -> simpleop -> prop) -> voiceop -> voiceop -> prop.
map LR F (overlays LR2 X) (overlays LR' Y) :- ratio.mult LR LR2 LR', map (map F) X Y.
map F (sequences X) (sequences Y) :- map F X Y.

%end.


(* ------------------- *)
(* to_op: convert from normal form back into op's *)

to_op : simpleop -> op -> prop.

to_op (simpleop FM_ FA_ GM_ LM_ PM_ PA_) Result :-
  map ratio.reduce [FM_, FA_, GM_, LM_, PM_, PA_] [FM, FA, GM, LM, PM, PA],
  if (eq FM (ratio 1 1)) then eq C1 [] else eq C1 [map (freqmult FM)],
  if (eq FA (ratio 0 1)) then eq C2 [] else eq C2 [map (freqadd FA)],
  if (eq GM (ratio 1 1)) then eq C3 [] else eq C3 [map (gainmult GM)],
  if (eq LM (ratio 1 1)) then eq C4 [] else eq C4 [map (lenmult LM)],
  if (eq PM (ratio 1 1)) then eq C5 [] else eq C5 [map (panmult PM)],
  if (eq PA (ratio 0 1)) then eq C6 [] else eq C6 [map (panadd PA)],
  concat [C1, C2, C3, C4, C5, C6] CS,
  if (eq CS []) then eq Result id
  else if (eq CS [X]) then eq Result X
  else eq Result (compose CS).

to_op (simpleop_id) (id).
to_op (simpleop_sil R) (map (silence R)).

to_op : normalop -> op -> prop.
to_op : voiceop -> op -> prop.

to_op (overlays LR [HD]) HD' :-
  to_op HD HD'.
to_op (overlays LR (HD :: TL)) (overlay HD' TL') :-
  to_op HD HD', to_op (overlays LR TL) TL'.

to_op (sequences [HD]) HD' :-
  to_op HD HD'.
to_op (sequences (HD :: TL)) (seq HD' TL') :-
  to_op HD HD', to_op (sequences TL) TL'.


(* ------------------- *)
(* normalize: the main thing (normal_op * op ~~> normal_op) *)

normalize : program -> normalprogram -> prop.
norm_compose_with : normalop -> op -> normalop -> prop.

normalize (program Point Op) (normalprogram Point Op') :-
  norm_compose_with (overlays (ratio 1 1) [ sequences [ simpleop_id ] ]) Op Op'.

norm_compose_with Normal id Normal.

norm_compose_with Normal (map F) Normal' :-
  if (eq F (lenmult (ratio 0 D)))
  then (log_error F `multiplying length by 0 is not allowed!`, failure)
  else success,
  simpleop.from_pointop F F',
  lrof F' LR,
  normalop.map LR (fun x y => simpleop.combine x F' y) Normal Normal'.

norm_compose_with Normal (overlay O1 O2) Result :-
  norm_compose_with Normal O1 Result1,
  norm_compose_with Normal O2 Result2,

  lrof Result1 LR1, lrof Result2 LR2,
  ratio.difforzero LR2 LR1 SLR1,
  ratio.difforzero LR1 LR2 SLR2,

  normalop.silence Result1 SLR1 Silence1,
  normalop.sequence Result1 Silence1 Result1',

  normalop.silence Result2 SLR2 Silence2,
  normalop.sequence Result2 Silence2 Result2',

  normalop.overlay Result1' Result2' Result.

norm_compose_with (overlays LR Voices) (seq O1 O2) Result :-
  norm_compose_with (overlays LR Voices) O1 (overlays LR1 Voices1),
  norm_compose_with (overlays LR Voices) O2 (overlays LR2 Voices2),

  (* CommonVoices1 | CommonVoices2
     --------------+--------------
     ExtraVoices1  | Silence1
     -------------+---------------
     Silence2      | ExtraVoices2
   *)

  length Voices N,
  length CommonVoices1 N,
  length CommonVoices2 N,
  append CommonVoices1 ExtraVoices1 Voices1,
  append CommonVoices2 ExtraVoices2 Voices2,

  normalop.silence (overlays LR1 ExtraVoices1) LR2 Silence1,
  normalop.silence (overlays LR2 ExtraVoices2) LR1 Silence2,

  normalop.sequence (overlays LR1 CommonVoices1) (overlays LR2 CommonVoices2) CommonVoices',
  normalop.sequence (overlays LR1 ExtraVoices1) Silence1 Extra1',
  normalop.sequence Silence2 (overlays LR2 ExtraVoices2) Extra2',
  fold1 normalop.overlay [CommonVoices', Extra1', Extra2'] Result.

norm_compose_with Normal (compose O1 O2) Normal'' :-
  norm_compose_with Normal O1 Normal',
  norm_compose_with Normal' O2 Normal''.

op_var : type.
var : op_var -> op.
var_def : op_var -> op -> ratio -> prop.

lrof (var X) LR :- var_def X _ LR.

norm_compose_with Normal (var X) Result :-
  var_def X Op _,
  norm_compose_with Normal Op Result.

norm_compose_with Normal (let Op1 (bind _ X_Op2)) Result :-
  norm_compose_with (overlays (ratio 1 1) [ sequences [ simpleop_id ] ]) Op1 Result1,
  lrof Result1 LR,
  to_op Result1 Result1',
  (x:op_var -> var_def x Result1' LR -> norm_compose_with Normal (X_Op2 (var x)) Result).

(* ------------------- *)
(* desugaring *)

desugar, desugar_cases : [A] A -> A -> prop.

desugar X Y :-
  demand.case_otherwise
    (desugar_cases X Y)
    (structural @desugar X Y).

desugar_cases (decimal (posint Dec) FracS) Ratio :-
  ratio.fromdecimal Dec FracS Ratio.

desugar_cases (decimal (negint Dec) FracS) Ratio :-
  ratio.fromdecimal Dec FracS (ratio N D),
  desugar (signedratio (negint N) D) Ratio.

desugar_cases (signedratio (posint P) D) (ratio P D).
desugar_cases (signedratio (negint P) D) (ratio N D) :-
  sub 0 P N.

desugar_cases (seq [O]) O' :- desugar O O'.
desugar_cases (seq (HD :: TL)) (seq HD' TL') :-
  desugar HD HD',
  desugar (seq TL) TL'.

desugar_cases (overlay [O]) O' :- desugar O O'.
desugar_cases (overlay (HD :: TL)) (overlay HD' TL') :-
  desugar HD HD',
  desugar (overlay TL) TL'.

desugar_cases (compose [O]) O' :- desugar O O'.
desugar_cases (compose (HD :: TL)) (compose HD' TL') :-
  desugar HD HD',
  desugar (compose TL) TL'.

desugar_cases (withlrof Op1 Op2) (map (lenmult Ratio)) :-
  desugar Op1 Op1', desugar Op2 Op2',
  lrof Op1' R1, lrof Op2' R2,
  ratio.div R1 R2 Ratio.

desugar_cases (fit Op1 (fitlength Op2)) Result :-
  desugar Op1 Op1', desugar Op2 Op2',
  desugar (compose Op1' (withlrof Op2' Op1')) Result.

desugar_cases (repeat N) R :-
  length L N, map (fun u => eq id) L L', desugar (seq L') R.


(* ------------------- *)
(* stuff we get for free *)

parser : string -> concrete program -> prop.
parser X Y :- syntax.parse_opt syntax.cprogram X Y.

resolver : concrete program -> program -> prop.
resolver X Y :- concrete.resolve X Y.

printer : program -> string -> prop.
printer X Y :- syntax.pretty syntax.sprogram X Y.


(* ------------------- *)
(* reconvert: normal_op ~~> op *)

reconvert : normalprogram -> program -> prop.
reconvert : normalop -> op -> prop.
reconvert : voiceop -> op -> prop.
reconvert : simpleop -> op -> prop.

reconvert (normalprogram Point Op) (program Point Op') :-
  reconvert Op Op'.

reconvert (overlays LR OS) (overlay OS') :-
  map reconvert OS OS'.

reconvert (sequences SS) (seq SS') :-
  map to_op SS SS'.


(* ---------------- *)
(* drivers *)

slowprint_compiler : string -> string -> prop.
slowprint_compiler X Y :-
  pipe [parser, resolver, desugar, normalize, reconvert, printer] X Y.

fastprint_compiler : string -> string -> prop.
fastprint_compiler X Y :-
  pipe [parser, resolver, desugar, normalize, reconvert, fastprinter] X Y.

fulltransform : string -> prop.
fulltransform X :-
  fastprint_compiler X Y,
  print_string `
>>>
${Y}
<<<
`.
